# 地方志数据智能管理系统 - 漏洞管理
"""漏洞扫描、CVE跟踪、修复管理"""

import asyncio
import hashlib
import json
import re
import subprocess
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set
import structlog

logger = structlog.get_logger()


class VulnerabilitySeverity(str, Enum):
    """漏洞严重程度"""
    NONE = "none"
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnerabilityStatus(str, Enum):
    """漏洞状态"""
    OPEN = "open"
    IN_PROGRESS = "in_progress"
    FIXED = "fixed"
    ACCEPTED = "accepted"  # 接受风险
    FALSE_POSITIVE = "false_positive"


class VulnerabilityType(str, Enum):
    """漏洞类型"""
    DEPENDENCY = "dependency"      # 依赖漏洞
    CODE = "code"                   # 代码漏洞
    CONFIGURATION = "configuration"  # 配置漏洞
    INFRASTRUCTURE = "infrastructure"  # 基础设施漏洞
    SECRET = "secret"               # 密钥泄露
    CONTAINER = "container"         # 容器漏洞


@dataclass
class CVEInfo:
    """CVE信息"""
    cve_id: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    cvss_vector: str = ""
    references: List[str] = field(default_factory=list)
    published_date: datetime = None
    modified_date: datetime = None
    affected_products: List[str] = field(default_factory=list)


@dataclass
class Vulnerability:
    """漏洞"""
    id: str
    vuln_type: VulnerabilityType
    severity: VulnerabilitySeverity
    status: VulnerabilityStatus
    title: str
    description: str
    affected_component: str
    affected_version: str = ""
    fixed_version: str = ""
    cve_info: Optional[CVEInfo] = None
    discovered_at: datetime = None
    fixed_at: datetime = None
    assignee: str = ""
    remediation: str = ""
    proof_of_concept: str = ""
    false_positive_reason: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.discovered_at:
            self.discovered_at = datetime.now()
    
    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "type": self.vuln_type.value,
            "severity": self.severity.value,
            "status": self.status.value,
            "title": self.title,
            "description": self.description,
            "affected_component": self.affected_component,
            "affected_version": self.affected_version,
            "fixed_version": self.fixed_version,
            "cve_id": self.cve_info.cve_id if self.cve_info else None,
            "discovered_at": self.discovered_at.isoformat() if self.discovered_at else None,
            "fixed_at": self.fixed_at.isoformat() if self.fixed_at else None,
            "assignee": self.assignee,
            "remediation": self.remediation
        }


@dataclass
class ScanResult:
    """扫描结果"""
    scan_id: str
    scan_type: str
    started_at: datetime
    completed_at: datetime = None
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    summary: Dict[str, int] = field(default_factory=dict)
    
    def __post_init__(self):
        if not self.summary:
            self.summary = {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "total": 0
            }


class DependencyScanner:
    """依赖漏洞扫描器"""
    
    # 已知漏洞库（简化示例）
    KNOWN_VULNERABILITIES = {
        "requests": {
            "2.25.0": [
                CVEInfo(
                    cve_id="CVE-2023-32681",
                    description="Unintended leak of Proxy-Authorization header",
                    severity=VulnerabilitySeverity.MEDIUM,
                    cvss_score=6.1
                )
            ]
        },
        "urllib3": {
            "1.26.0": [
                CVEInfo(
                    cve_id="CVE-2023-43804",
                    description="Cookie Leakage",
                    severity=VulnerabilitySeverity.HIGH,
                    cvss_score=8.1
                )
            ]
        }
    }
    
    def __init__(self, requirements_path: str = "requirements.txt"):
        self.requirements_path = Path(requirements_path)
    
    async def scan(self) -> List[Vulnerability]:
        """扫描依赖漏洞"""
        vulnerabilities = []
        
        # 解析requirements.txt
        dependencies = self._parse_requirements()
        
        for package, version in dependencies.items():
            vulns = await self._check_package(package, version)
            vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    def _parse_requirements(self) -> Dict[str, str]:
        """解析requirements文件"""
        dependencies = {}
        
        if not self.requirements_path.exists():
            return dependencies
        
        with open(self.requirements_path, "r") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                
                # 解析包名和版本
                match = re.match(r'^([a-zA-Z0-9_-]+)([<>=!]+)?(.+)?$', line)
                if match:
                    package = match.group(1).lower()
                    version = match.group(3) or "unknown"
                    dependencies[package] = version
        
        return dependencies
    
    async def _check_package(self, package: str, version: str) -> List[Vulnerability]:
        """检查单个包的漏洞"""
        vulnerabilities = []
        
        # 检查本地漏洞库
        if package in self.KNOWN_VULNERABILITIES:
            for vuln_version, cves in self.KNOWN_VULNERABILITIES[package].items():
                if self._version_affected(version, vuln_version):
                    for cve in cves:
                        vuln = Vulnerability(
                            id=f"dep_{package}_{cve.cve_id}",
                            vuln_type=VulnerabilityType.DEPENDENCY,
                            severity=cve.severity,
                            status=VulnerabilityStatus.OPEN,
                            title=f"{package} {cve.cve_id}",
                            description=cve.description,
                            affected_component=package,
                            affected_version=version,
                            cve_info=cve,
                            remediation=f"升级 {package} 到最新版本"
                        )
                        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _version_affected(self, installed: str, vulnerable: str) -> bool:
        """检查版本是否受影响（简化实现）"""
        try:
            from packaging import version
            return version.parse(installed) <= version.parse(vulnerable)
        except:
            return installed == vulnerable


class CodeScanner:
    """代码安全扫描器"""
    
    # 安全问题模式
    SECURITY_PATTERNS = {
        "hardcoded_secret": {
            "pattern": r'(password|secret|api_key|token)\s*=\s*["\'][^"\']{8,}["\']',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "硬编码的密钥或密码"
        },
        "sql_injection": {
            "pattern": r'execute\s*\(\s*["\'].*%s.*["\']',
            "severity": VulnerabilitySeverity.CRITICAL,
            "description": "潜在的SQL注入"
        },
        "eval_usage": {
            "pattern": r'\beval\s*\(',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "使用eval函数"
        },
        "pickle_usage": {
            "pattern": r'pickle\.loads?\s*\(',
            "severity": VulnerabilitySeverity.MEDIUM,
            "description": "不安全的pickle反序列化"
        },
        "subprocess_shell": {
            "pattern": r'subprocess\.(call|run|Popen)\s*\([^)]*shell\s*=\s*True',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "使用shell=True的子进程调用"
        },
        "debug_enabled": {
            "pattern": r'DEBUG\s*=\s*True',
            "severity": VulnerabilitySeverity.MEDIUM,
            "description": "调试模式已启用"
        },
        "weak_crypto": {
            "pattern": r'\b(md5|sha1)\s*\(',
            "severity": VulnerabilitySeverity.MEDIUM,
            "description": "使用弱加密算法"
        }
    }
    
    def __init__(self, scan_path: str = "."):
        self.scan_path = Path(scan_path)
        self._compiled_patterns = {
            name: re.compile(info["pattern"], re.IGNORECASE)
            for name, info in self.SECURITY_PATTERNS.items()
        }
    
    async def scan(self, file_extensions: List[str] = None) -> List[Vulnerability]:
        """扫描代码"""
        if file_extensions is None:
            file_extensions = [".py", ".js", ".ts", ".java"]
        
        vulnerabilities = []
        
        for ext in file_extensions:
            for file_path in self.scan_path.rglob(f"*{ext}"):
                # 跳过node_modules和.git
                if "node_modules" in str(file_path) or ".git" in str(file_path):
                    continue
                
                try:
                    file_vulns = await self._scan_file(file_path)
                    vulnerabilities.extend(file_vulns)
                except Exception as e:
                    logger.warning("扫描文件失败", file=str(file_path), error=str(e))
        
        return vulnerabilities
    
    async def _scan_file(self, file_path: Path) -> List[Vulnerability]:
        """扫描单个文件"""
        vulnerabilities = []
        
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
                lines = content.split("\n")
        except Exception:
            return []
        
        for name, pattern in self._compiled_patterns.items():
            matches = pattern.finditer(content)
            for match in matches:
                # 获取行号
                line_num = content[:match.start()].count("\n") + 1
                line_content = lines[line_num - 1] if line_num <= len(lines) else ""
                
                info = self.SECURITY_PATTERNS[name]
                
                vuln = Vulnerability(
                    id=f"code_{hashlib.md5(f'{file_path}:{line_num}:{name}'.encode()).hexdigest()[:12]}",
                    vuln_type=VulnerabilityType.CODE,
                    severity=info["severity"],
                    status=VulnerabilityStatus.OPEN,
                    title=f"{info['description']} - {file_path.name}:{line_num}",
                    description=f"{info['description']}\n代码: {line_content.strip()[:100]}",
                    affected_component=str(file_path),
                    metadata={
                        "file": str(file_path),
                        "line": line_num,
                        "match": match.group(0)[:50]
                    },
                    remediation=self._get_remediation(name)
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _get_remediation(self, issue_type: str) -> str:
        """获取修复建议"""
        remediations = {
            "hardcoded_secret": "使用环境变量或密钥管理服务存储敏感信息",
            "sql_injection": "使用参数化查询或ORM",
            "eval_usage": "避免使用eval，改用安全的替代方案",
            "pickle_usage": "使用JSON或其他安全的序列化格式",
            "subprocess_shell": "避免使用shell=True，使用列表参数",
            "debug_enabled": "生产环境禁用调试模式",
            "weak_crypto": "使用SHA-256或更强的哈希算法"
        }
        return remediations.get(issue_type, "请审查并修复此安全问题")


class ConfigurationScanner:
    """配置安全扫描器"""
    
    def __init__(self):
        self.checks = [
            self._check_debug_mode,
            self._check_secret_key,
            self._check_cors,
            self._check_https,
            self._check_logging
        ]
    
    async def scan(self, config: Dict[str, Any]) -> List[Vulnerability]:
        """扫描配置"""
        vulnerabilities = []
        
        for check in self.checks:
            vuln = await check(config)
            if vuln:
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    async def _check_debug_mode(self, config: Dict) -> Optional[Vulnerability]:
        """检查调试模式"""
        if config.get("DEBUG", False) or config.get("debug", False):
            return Vulnerability(
                id="config_debug_enabled",
                vuln_type=VulnerabilityType.CONFIGURATION,
                severity=VulnerabilitySeverity.HIGH,
                status=VulnerabilityStatus.OPEN,
                title="生产环境调试模式已启用",
                description="调试模式在生产环境应被禁用",
                affected_component="application_config",
                remediation="设置 DEBUG=False"
            )
        return None
    
    async def _check_secret_key(self, config: Dict) -> Optional[Vulnerability]:
        """检查密钥强度"""
        secret = config.get("SECRET_KEY", config.get("secret_key", ""))
        
        if not secret:
            return Vulnerability(
                id="config_no_secret",
                vuln_type=VulnerabilityType.CONFIGURATION,
                severity=VulnerabilitySeverity.CRITICAL,
                status=VulnerabilityStatus.OPEN,
                title="未配置密钥",
                description="应用密钥未配置",
                affected_component="application_config",
                remediation="配置强随机密钥"
            )
        
        weak_secrets = ["secret", "changeme", "your-secret-key", "development"]
        if any(ws in secret.lower() for ws in weak_secrets) or len(secret) < 32:
            return Vulnerability(
                id="config_weak_secret",
                vuln_type=VulnerabilityType.CONFIGURATION,
                severity=VulnerabilitySeverity.HIGH,
                status=VulnerabilityStatus.OPEN,
                title="弱密钥",
                description="应用密钥强度不足",
                affected_component="application_config",
                remediation="使用至少32字节的随机密钥"
            )
        
        return None
    
    async def _check_cors(self, config: Dict) -> Optional[Vulnerability]:
        """检查CORS配置"""
        cors = config.get("CORS_ORIGINS", config.get("cors_origins", []))
        
        if "*" in cors:
            return Vulnerability(
                id="config_cors_wildcard",
                vuln_type=VulnerabilityType.CONFIGURATION,
                severity=VulnerabilitySeverity.MEDIUM,
                status=VulnerabilityStatus.OPEN,
                title="CORS配置过于宽松",
                description="CORS允许所有来源",
                affected_component="cors_config",
                remediation="配置具体的允许来源列表"
            )
        
        return None
    
    async def _check_https(self, config: Dict) -> Optional[Vulnerability]:
        """检查HTTPS配置"""
        if not config.get("FORCE_HTTPS", config.get("force_https", True)):
            return Vulnerability(
                id="config_no_https",
                vuln_type=VulnerabilityType.CONFIGURATION,
                severity=VulnerabilitySeverity.HIGH,
                status=VulnerabilityStatus.OPEN,
                title="未强制HTTPS",
                description="应强制使用HTTPS",
                affected_component="transport_config",
                remediation="启用HTTPS重定向"
            )
        return None
    
    async def _check_logging(self, config: Dict) -> Optional[Vulnerability]:
        """检查日志配置"""
        log_level = config.get("LOG_LEVEL", config.get("log_level", "INFO"))
        
        if log_level.upper() == "DEBUG":
            return Vulnerability(
                id="config_debug_logging",
                vuln_type=VulnerabilityType.CONFIGURATION,
                severity=VulnerabilitySeverity.LOW,
                status=VulnerabilityStatus.OPEN,
                title="调试日志级别",
                description="生产环境不应使用DEBUG日志级别",
                affected_component="logging_config",
                remediation="设置日志级别为INFO或更高"
            )
        return None


class VulnerabilityManager:
    """漏洞管理器"""
    
    def __init__(self, storage_path: str = "data/vulnerabilities"):
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)
        
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.scan_history: List[ScanResult] = []
        
        self.dependency_scanner = DependencyScanner()
        self.code_scanner = CodeScanner()
        self.config_scanner = ConfigurationScanner()
        
        self._load_data()
    
    def _load_data(self):
        """加载数据"""
        vuln_file = self.storage_path / "vulnerabilities.json"
        if vuln_file.exists():
            try:
                with open(vuln_file, "r") as f:
                    data = json.load(f)
                    for v in data:
                        vuln = self._dict_to_vuln(v)
                        self.vulnerabilities[vuln.id] = vuln
            except Exception as e:
                logger.error("加载漏洞数据失败", error=str(e))
    
    def _save_data(self):
        """保存数据"""
        vuln_file = self.storage_path / "vulnerabilities.json"
        with open(vuln_file, "w") as f:
            json.dump([v.to_dict() for v in self.vulnerabilities.values()], f, indent=2)
    
    def _dict_to_vuln(self, data: Dict) -> Vulnerability:
        """字典转漏洞对象"""
        return Vulnerability(
            id=data["id"],
            vuln_type=VulnerabilityType(data["type"]),
            severity=VulnerabilitySeverity(data["severity"]),
            status=VulnerabilityStatus(data["status"]),
            title=data["title"],
            description=data["description"],
            affected_component=data["affected_component"],
            affected_version=data.get("affected_version", ""),
            fixed_version=data.get("fixed_version", ""),
            assignee=data.get("assignee", ""),
            remediation=data.get("remediation", ""),
            discovered_at=datetime.fromisoformat(data["discovered_at"]) if data.get("discovered_at") else None,
            fixed_at=datetime.fromisoformat(data["fixed_at"]) if data.get("fixed_at") else None
        )
    
    async def run_full_scan(self, config: Dict = None) -> ScanResult:
        """运行完整扫描"""
        scan_id = f"scan_{int(datetime.now().timestamp())}"
        result = ScanResult(
            scan_id=scan_id,
            scan_type="full",
            started_at=datetime.now()
        )
        
        # 依赖扫描
        dep_vulns = await self.dependency_scanner.scan()
        result.vulnerabilities.extend(dep_vulns)
        
        # 代码扫描
        code_vulns = await self.code_scanner.scan()
        result.vulnerabilities.extend(code_vulns)
        
        # 配置扫描
        if config:
            config_vulns = await self.config_scanner.scan(config)
            result.vulnerabilities.extend(config_vulns)
        
        result.completed_at = datetime.now()
        
        # 统计
        for vuln in result.vulnerabilities:
            result.summary[vuln.severity.value] = result.summary.get(vuln.severity.value, 0) + 1
            result.summary["total"] += 1
            
            # 添加到管理器
            if vuln.id not in self.vulnerabilities:
                self.vulnerabilities[vuln.id] = vuln
        
        self.scan_history.append(result)
        self._save_data()
        
        logger.info(
            "漏洞扫描完成",
            scan_id=scan_id,
            total=result.summary["total"],
            critical=result.summary.get("critical", 0),
            high=result.summary.get("high", 0)
        )
        
        return result
    
    def update_status(
        self,
        vuln_id: str,
        status: VulnerabilityStatus,
        assignee: str = None,
        fixed_version: str = None,
        false_positive_reason: str = None
    ):
        """更新漏洞状态"""
        if vuln_id not in self.vulnerabilities:
            raise ValueError(f"漏洞不存在: {vuln_id}")
        
        vuln = self.vulnerabilities[vuln_id]
        vuln.status = status
        
        if assignee:
            vuln.assignee = assignee
        
        if fixed_version:
            vuln.fixed_version = fixed_version
        
        if status == VulnerabilityStatus.FIXED:
            vuln.fixed_at = datetime.now()
        
        if status == VulnerabilityStatus.FALSE_POSITIVE and false_positive_reason:
            vuln.false_positive_reason = false_positive_reason
        
        self._save_data()
    
    def get_open_vulnerabilities(
        self,
        severity: VulnerabilitySeverity = None
    ) -> List[Vulnerability]:
        """获取开放的漏洞"""
        results = []
        for vuln in self.vulnerabilities.values():
            if vuln.status in [VulnerabilityStatus.OPEN, VulnerabilityStatus.IN_PROGRESS]:
                if severity is None or vuln.severity == severity:
                    results.append(vuln)
        
        # 按严重程度排序
        severity_order = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 1,
            VulnerabilitySeverity.MEDIUM: 2,
            VulnerabilitySeverity.LOW: 3,
            VulnerabilitySeverity.NONE: 4
        }
        results.sort(key=lambda v: severity_order[v.severity])
        
        return results
    
    def get_statistics(self) -> Dict[str, Any]:
        """获取统计信息"""
        by_severity = {}
        by_status = {}
        by_type = {}
        
        for vuln in self.vulnerabilities.values():
            by_severity[vuln.severity.value] = by_severity.get(vuln.severity.value, 0) + 1
            by_status[vuln.status.value] = by_status.get(vuln.status.value, 0) + 1
            by_type[vuln.vuln_type.value] = by_type.get(vuln.vuln_type.value, 0) + 1
        
        # 计算MTTR（平均修复时间）
        fixed_vulns = [v for v in self.vulnerabilities.values() 
                       if v.status == VulnerabilityStatus.FIXED and v.fixed_at and v.discovered_at]
        
        mttr = 0
        if fixed_vulns:
            total_time = sum((v.fixed_at - v.discovered_at).total_seconds() for v in fixed_vulns)
            mttr = total_time / len(fixed_vulns) / 3600  # 小时
        
        return {
            "total": len(self.vulnerabilities),
            "by_severity": by_severity,
            "by_status": by_status,
            "by_type": by_type,
            "open_count": by_status.get("open", 0) + by_status.get("in_progress", 0),
            "mttr_hours": round(mttr, 2),
            "last_scan": self.scan_history[-1].started_at.isoformat() if self.scan_history else None
        }
